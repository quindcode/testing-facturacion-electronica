name:  Cursor Agent - PR Reviewer (Powered by Gemini)

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  screenplay-code-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout del c贸digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name:  Extraer Reglas de Cursor (.mdc)
        id: extract_rules
        run: |
          # Lee absolutamente todos los archivos .mdc y los consolida con una separaci贸n clara
          RULES_CONTEXT=""
          for file in .cursor/rules/*.mdc; do
            if [ -f "$file" ]; then
              RULES_CONTEXT="$RULES_CONTEXT\n\n--- INICIO DE REGLA: $file ---\n$(cat "$file")\n--- FIN DE REGLA ---"
            fi
          done
          
          if [ -z "$RULES_CONTEXT" ]; then
            RULES_CONTEXT="No se encontraron reglas espec铆ficas en .cursor/rules/"
          fi
          
          echo "CURSOR_RULES<<EOF" >> $GITHUB_ENV
          echo -e "$RULES_CONTEXT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name:  Obtener el Diff del PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr diff ${{ github.event.pull_request.number }} > pr_diff.txt

      - name:  Revisar PR con Gemini y Comentar
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          python3 -c '
          import os, json, urllib.request, subprocess
          
          api_key = os.environ.get("GEMINI_API_KEY")
          pr_number = os.environ.get("PR_NUMBER")
          cursor_rules = os.environ.get("CURSOR_RULES", "")
          
          # 1. Leer el diff
          with open("pr_diff.txt", "r") as f:
              pr_diff = f.read()
          
          if not pr_diff.strip():
              print("No hay cambios en el c贸digo para revisar.")
              exit(0)
          
          # 2. Extraer los archivos completos para contexto
          result = subprocess.run(["gh", "pr", "view", pr_number, "--json", "files", "--jq", ".files[].path"], capture_output=True, text=True)
          changed_files = [f for f in result.stdout.splitlines() if f.endswith(".java") or f.endswith(".md") or f.endswith(".feature")]
          
          archivos_completos = ""
          for f_path in changed_files:
              if os.path.exists(f_path):
                  with open(f_path, "r", encoding="utf-8") as file:
                      archivos_completos += f"\n\n==== RUTA DEL ARCHIVO: {f_path} ====\n```\n{file.read()}\n```\n"
          
          # 3. Prompt Din谩mico basado en Globs
          prompt = f"""
          Eres un motor avanzado de revisi贸n de c贸digo automatizado que emula el comportamiento de "Cursor IDE".
          
          REGLAS DEL PROYECTO (.mdc):
          A continuaci贸n se listan las reglas del proyecto. Presta especial atenci贸n a los metadatos `globs` y al `# Rol`.
          <cursor_rules>
          {cursor_rules}
          </cursor_rules>
          
          ARCHIVOS A AUDITAR (CDIGO COMPLETO):
          <archivos>
          {archivos_completos}
          </archivos>
          
          EL DIFF (Cambios de este PR):
          <diff>
          {pr_diff}
          </diff>
          
          INSTRUCCIONES CRTICAS DE AUDITORA:
          1. MATCHING DE GLOBS: Por cada archivo en <archivos>, lee su "RUTA DEL ARCHIVO". Busca en las <cursor_rules> qu茅 bloque tiene un patr贸n `globs` que coincida con esa ruta (ej. si la ruta tiene "tasks", aplica la regla de tasks; si es "README.md", aplica la regla de documentaci贸n).
          2. ASUME EL ROL: Adopta estrictamente el `# Rol` de la regla que hizo match para auditar ese archivo en espec铆fico.
          3. AUDITORA PROFUNDA: Revisa el archivo COMPLETO usando las reglas espec铆ficas de ese glob. No te limites a auditar solo las l铆neas nuevas del <diff>. Si el archivo viola la arquitectura de su carpeta, es un error.
          4. REPORTE: Si encuentras violaciones, redacta un comentario constructivo en Markdown. Debes mencionar expl铆citamente qu茅 archivo fall贸, qu茅 regla del .mdc se est谩 violando y proveer el c贸digo corregido.
          5. Si todos los archivos cumplen sus respectivas reglas de arquitectura, responde NICAMENTE con la palabra "LGTM".
          """
          
          # 4. Llamada a Gemini 2.5 Flash
          payload = {
              "systemInstruction": {
                  "parts": [{"text": "Eres un auditor estricto de c贸digo automatizado. Tu precisi贸n arquitect贸nica es absoluta."}]
              },
              "contents": [{"parts": [{"text": prompt}]}],
              "generationConfig": {"temperature": 0.1} # S煤per anal铆tico, cero alucinaciones
          }
          
          url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key={api_key}"
          req = urllib.request.Request(url, data=json.dumps(payload).encode("utf-8"), headers={"Content-Type": "application/json"})
          
          try:
              with urllib.request.urlopen(req) as response:
                  res_data = json.loads(response.read())
                  ai_comment = res_data["candidates"][0]["content"]["parts"][0]["text"].strip()
          
                  if ai_comment != "LGTM":
                      with open("comment.md", "w") as f:
                          f.write("###  Auditor铆a de Arquitectura (Cursor Rules)\n\n" + ai_comment)
          
                      print("Se encontraron violaciones a las reglas. Publicando en el PR...")
                      subprocess.run(["gh", "pr", "comment", pr_number, "-F", "comment.md"])
                  else:
                      print("El c贸digo cumple con todas las reglas de los globs. LGTM.")
          
          except Exception as e:
              print(f"Error al comunicarse con Gemini o GitHub: {e}")
              exit(1)
          '