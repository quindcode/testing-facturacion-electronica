name: ü§ñ Cursor Agent - PR Reviewer (Powered by Gemini)

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  screenplay-code-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout del c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Obtener el Diff del PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh pr diff ${{ github.event.pull_request.number }} > pr_diff.txt

      - name: ü§ñ Revisar PR con Gemini y Comentar
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          python3 -c '
          import os, json, urllib.request, subprocess, glob
          
          api_key = os.environ.get("GEMINI_API_KEY")
          pr_number = os.environ.get("PR_NUMBER")
          
          # 1. Leer reglas de Cursor directamente en Python (A prueba de fallos)
          cursor_rules = ""
          mdc_files = glob.glob(".cursor/rules/*.mdc")
          for filepath in mdc_files:
              with open(filepath, "r", encoding="utf-8") as rf:
                  cursor_rules += f"\n--- REGLA: {filepath} ---\n{rf.read()}\n"
          
          print(f"üõ†Ô∏è DEBUG: Se cargaron {len(mdc_files)} archivos de reglas .mdc.")
          
          # 2. Leer el diff
          with open("pr_diff.txt", "r", encoding="utf-8") as f:
              pr_diff = f.read()
          
          if not pr_diff.strip():
              print("No hay cambios en el c√≥digo para revisar.")
              exit(0)
          
          # 3. Extraer los archivos completos para contexto real
          result = subprocess.run(["gh", "pr", "view", pr_number, "--json", "files", "--jq", ".files[].path"], capture_output=True, text=True)
          changed_files = [f for f in result.stdout.splitlines() if f.endswith(".java") or f.endswith(".md") or f.endswith(".feature")]
          
          print(f"üõ†Ô∏è DEBUG: Analizando {len(changed_files)} archivos modificados en este PR: {changed_files}")
          
          archivos_completos = ""
          for f_path in changed_files:
              if os.path.exists(f_path):
                  with open(f_path, "r", encoding="utf-8") as file:
                      archivos_completos += f"\n\n==== RUTA DEL ARCHIVO: {f_path} ====\n```\n{file.read()}\n```\n"
          
          # 4. Prompt Din√°mico Extremo
          prompt = f"""
          Eres un Arquitecto de Pruebas Automatizadas (Serenity BDD/Screenplay) implacable y meticuloso. Tu misi√≥n es auditar el c√≥digo de este Pull Request.
          
          PARTE A: REGLAS ESPEC√çFICAS DE CARPETA (.mdc)
          Lee estos archivos de configuraci√≥n. Si la ruta de un archivo modificado coincide con el `globs` de una regla, DEBES juzgar el archivo asumiendo ese `# Rol` y aplicando esas reglas al pie de la letra.
          <cursor_rules>
          {cursor_rules}
          </cursor_rules>
          
          PARTE B: MEJORES PR√ÅCTICAS GENERALES (NO NEGOCIABLES)
          Adem√°s de las reglas anteriores, debes penalizar severamente:
          1. Logs en Producci√≥n: Uso de `System.out.println` o `e.printStackTrace()`. Exige el uso de un Logger (SLF4J/Logback).
          2. Bloques Catch vac√≠os o malos manejos de excepciones.
          3. Nombres de variables incomprensibles o violaciones de Clean Code.
          4. Malos olores en archivos .feature (escenarios sin sentido, pasos ambiguos).
          
          ARCHIVOS A AUDITAR (C√ìDIGO COMPLETO):
          <archivos>
          {archivos_completos}
          </archivos>
          
          EL DIFF (Cambios que el dev hizo hoy):
          <diff>
          {pr_diff}
          </diff>
          
          INSTRUCCIONES DE RESPUESTA:
          - Cruza el c√≥digo de <archivos> con las reglas que correspondan en <cursor_rules> (basado en la ruta) y con la PARTE B.
          - Si encuentras CUALQUIER error, escribe un comentario severo pero formativo en Markdown, listando el archivo, el error detectado y c√≥mo solucionarlo.
          - Responde "LGTM" √öNICAMENTE si el c√≥digo es absolutamente perfecto en arquitectura y limpieza.
          """
          
          # Llamada a Gemini
          payload = {
              "systemInstruction": {
                  "parts": [{"text": "Eres un auditor de c√≥digo senior, cr√≠tico y detallista. No perdonas errores de Clean Code ni violaciones a Screenplay."}]
              },
              "contents": [{"parts": [{"text": prompt}]}],
              "generationConfig": {"temperature": 0.1}
          }
          
          url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key={api_key}"
          req = urllib.request.Request(url, data=json.dumps(payload).encode("utf-8"), headers={"Content-Type": "application/json"})
          
          try:
              with urllib.request.urlopen(req) as response:
                  res_data = json.loads(response.read())
                  ai_comment = res_data["candidates"][0]["content"]["parts"][0]["text"].strip()
          
                  if ai_comment != "LGTM":
                      with open("comment.md", "w", encoding="utf-8") as f:
                          f.write("### üö® Auditor√≠a de C√≥digo y Arquitectura (Gemini AI)\n\n" + ai_comment)
          
                      print("¬°Se detectaron malas pr√°cticas! Publicando comentario en GitHub...")
                      subprocess.run(["gh", "pr", "comment", pr_number, "-F", "comment.md"])
                  else:
                      print("El c√≥digo es perfecto. LGTM.")
          
          except Exception as e:
              print(f"Error cr√≠tico en la API: {e}")
              exit(1)
          '